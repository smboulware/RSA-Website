# RSA Python Code

# Theory
In order to use RSA encryption, you need to generate a public key (e, n) and a private key (d, n). Here, n is the product of two large primes p and q. In determining d and e, we also must calculate lambda = (p-1)(q-1). Then the greatest common divisor of e and lambda must be 1 as d must be the inverse of e mod lambda, and it is proven that e has an inverse mod lambda if and only if e does not share any factors with lambda. It is also necessary that e < n. Then, if we take a number c = m^e mod n, we get that c^d mod n = m. The proof of this is somewhat complicated, but it relies on the fact that C^d = M^ed = M^((p-1)(q-1)x+1) mod n where x is some integer. Then it has been proven that M^((p-1)(q-1)x) = 1 mod n, so we get C^d = M mod n. For my project, I choose ns that are not that large to make the numbers managable for the user, however this also means that it is not very secure. The n size can be easily edited, however.

# Key Generation
As the e value is public, it doesn't matter if it is the same every time, so I selected a prime slightly smaller than the size of n I am using. I then use the pycryptodome library to generate two large primes, p and q, of a certain bit size. Then I check to make sure the greatest common divisor of e and (p-1)(q-1) is 1 as then otherwise e would not have an inverse mod (p-1)(q-1). I also check that the primes are not the same as we do not want to have a perfect square. Then I can calculate n as p*q. (p-1)(q-1) is called lambda, but I have called it lamb in the program as lambda is already used for lambda functions in python. I can then find d as the lambda modular inverse of e using the pow function. The d, e, and n values are what need to be returned to the user.

# Encryption
This function takes in a message as a string, and e and n values, which are converted to integers. As RSA encodes integers, I had to determine a way to convert a string of text into numbers so that I could encode them. I decided to encode each character separately, as otherwise both the input integers and the required key values would become extremely large, and thus the exponentiation would be extremely slow. I do this by converting each character to its ASCII value then using the formula m^e mod n. Then I put each encoded character into a list, then put them together into a string. I used an fstring to make sure that each encoded character would be 4 digits, so I am able to break it up correctly for decryption. This works because I have set the bit number to be 12 for each prime, so n will always be in the thousands. Therefore a number mod n will never have more than 4 digits. This string of numbers is then returned.

# Decryption
This function takes in a string of numbers as the encrypted message, and d and n values. I take each group of 4 integers from the encrypted string and convert them to an int to get rid of the leading 0s. Then I decode that character using c^d mod n, and add it to the decoded string. Thus we get a string of text that is the same as the string inputted into the encryption function.

# Website Python Code
I implemented my program in a website. It has a homepage with basic instructions, and separate pages for each function. These functions go to a page with a form for inputs when the get method is used and go to a different page that displays the results when the post method used. For the key generation page, the user only has to click a button. I decided to choose the bit number (how large each prime is) myself to make sure it is large enough to encode ASCII values, but not so large that computation takes too long. I chose 12 bits for each prime, so that n would be in the thousands. As ASCII goes up to the 100s, n will be much larger than any value being encoded. I had to make n somewhat larger, however, so that generating a key would give a wide variety of d values with e set to 253. For encryption, I have the user input the key values and their message. However, once it is encrypted to a string, it becomes one long number. As html will not break a number in the middle to go onto the next line, I chose to insert spaces every 50 characters for readability. Then in the decryption post method, I remove all the spaces before putting it into the decryption function. 